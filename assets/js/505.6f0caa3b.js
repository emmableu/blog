(window.webpackJsonp=window.webpackJsonp||[]).push([[505],{877:function(t,a,r){"use strict";r.r(a);var e=r(9),v=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"深入理解javascript异步原理-source"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入理解javascript异步原理-source"}},[t._v("#")]),t._v(" 深入理解Javascript异步原理 "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("source"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("众所周知，Javascript是单线程运行的，那既然是单线程运行又是如何实现异步非阻塞操作的呢？下面带大家从Javascript原理层面，一步步剖析这个问题。")]),t._v(" "),a("h2",{attrs:{id:"javascript-process-thread-多进程与多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-process-thread-多进程与多线程"}},[t._v("#")]),t._v(" Javascript - Process, Thread，  多进程与多线程")]),t._v(" "),a("p",[t._v("我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？")]),t._v(" "),a("p",[t._v("官方的说法是："),a("strong",[t._v("进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位")]),t._v("。这两句话并不好理解，我们先来看张图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop11.png",alt:"Javascript异步"}})]),t._v(" "),a("ul",[a("li",[t._v("进程好比图中的"),a("strong",[t._v("工厂")]),t._v("，有单独的专属自己的工厂资源。")]),t._v(" "),a("li",[t._v("线程好比图中的"),a("strong",[t._v("工人")]),t._v("，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说"),a("strong",[t._v("一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线")]),t._v("；")]),t._v(" "),a("li",[a("strong",[t._v("工厂的空间是工人们共享的")]),t._v("，这象征"),a("strong",[t._v("一个进程的内存空间是共享的，每个线程都可用这些共享内存")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("多个工厂之间独立存在")]),t._v("。")])]),t._v(" "),a("p",[a("strong",[t._v("多进程与多线程")])]),t._v(" "),a("ul",[a("li",[t._v("多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。")]),t._v(" "),a("li",[t._v("多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。")])]),t._v(" "),a("p",[t._v("以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。")]),t._v(" "),a("h3",{attrs:{id:"浏览器内核"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核"}},[t._v("#")]),t._v(" 浏览器内核")]),t._v(" "),a("p",[t._v("简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。")]),t._v(" "),a("p",[t._v("浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("GUI 渲染线程")])]),t._v(" "),a("li",[a("p",[t._v("JavaScript引擎线程")])]),t._v(" "),a("li",[a("p",[t._v("定时触发器线程, e.g., setTimeout")])]),t._v(" "),a("li",[a("p",[t._v("事件触发线程")])]),t._v(" "),a("li",[a("p",[t._v("异步http请求线程")])])]),t._v(" "),a("h4",{attrs:{id:"gui渲染线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gui渲染线程"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#GUI%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B",title:"GUI渲染线程",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("GUI渲染线程")]),t._v(" "),a("ul",[a("li",[t._v("主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。")]),t._v(" "),a("li",[t._v("当界面需要重绘或者由于某种操作引发回流时，将执行该线程。")]),t._v(" "),a("li",[t._v("该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。")])]),t._v(" "),a("h4",{attrs:{id:"js引擎线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js引擎线程"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#JS%E5%BC%95%E6%93%8E%E7%BA%BF%E7%A8%8B",title:"JS引擎线程",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("JS引擎线程")]),t._v(" "),a("ul",[a("li",[t._v("该线程当然是主要负责处理 JavaScript脚本，执行代码。")]),t._v(" "),a("li",[t._v("也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。")]),t._v(" "),a("li",[t._v("当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。")])]),t._v(" "),a("h4",{attrs:{id:"定时器触发线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时器触发线程"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A6%E5%8F%91%E7%BA%BF%E7%A8%8B",title:"定时器触发线程",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("定时器触发线程")]),t._v(" "),a("ul",[a("li",[t._v("负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。")]),t._v(" "),a("li",[t._v("主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。")])]),t._v(" "),a("h4",{attrs:{id:"事件触发线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件触发线程"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%BA%BF%E7%A8%8B",title:"事件触发线程",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("事件触发线程")]),t._v(" "),a("p",[t._v("主要负责将准备好的事件交给 JS引擎线程执行。"),a("br"),t._v("\n比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。")]),t._v(" "),a("h4",{attrs:{id:"异步http请求线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步http请求线程"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#%E5%BC%82%E6%AD%A5http%E8%AF%B7%E6%B1%82%E7%BA%BF%E7%A8%8B",title:"异步http请求线程",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("异步http请求线程")]),t._v(" "),a("ul",[a("li",[t._v("负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。")]),t._v(" "),a("li",[t._v("主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。")])]),t._v(" "),a("h3",{attrs:{id:"javascript引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript引擎"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#Javascript%E5%BC%95%E6%93%8E",title:"Javascript引擎",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("Javascript引擎")]),t._v(" "),a("p",[t._v("Google V8引擎是目前最流行的Javascript引擎之一，它使用在Chrome浏览器和Node.js中。下面是V8引擎一个简化的视图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/emmableu/image/master/202209141930450.png",alt:""}})]),t._v(" "),a("p",[t._v("V8引擎主要包含两个部分：")]),t._v(" "),a("ul",[a("li",[t._v("Memory Heap — 分配内存将会在这里发生")]),t._v(" "),a("li",[t._v("Call Stack — 回调函数将会在这里执行")])]),t._v(" "),a("h3",{attrs:{id:"runtime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#Runtime",title:"Runtime",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("Runtime")]),t._v(" "),a("p",[t._v("有一些APIs被开发者在浏览器中经常使用到（如：“setTimeout”），然而这些APIs也许并不是由Javascript引擎提供的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/emmableu/image/master/202209141934378.png",alt:""}})]),t._v(" "),a("p",[t._v("诸如DOM、AJAX、setTimeout等其它是由浏览器提供的，我们称之为WEB APIs。")]),t._v(" "),a("p",[t._v("接下来，我们将谈谈非常流行的"),a("strong",[t._v("callback queue")]),t._v("和"),a("strong",[t._v("event loop")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"call-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-stack"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#Call-Stack",title:"Call Stack",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("Call Stack")]),t._v(" "),a("p",[t._v("Javascript是一种单线程的编程语言，这导致它只有单一的Call Stack。因此在某一时刻，他只能做一件事。")]),t._v(" "),a("p",[t._v("Call Stack是一种数据结构，他主要是记录Javascript整个执行过程。当Javascript的虚拟机执行一个函数，就会把这个函数推送到Call Stack中。当这个函数返回值或是执行完毕后，这个函数就会从Call Stack删除。")]),t._v(" "),a("p",[t._v("如以下示例：")]),t._v(" "),a("p",[t._v("function multiply(x, y) {"),a("br"),t._v("\nreturn x * y;"),a("br"),t._v("\n}"),a("br"),t._v("\nfunction printSquare(x) {"),a("br"),t._v("\nvar s = multiply(x, x);"),a("br"),t._v("\nconsole.log(s);"),a("br"),t._v("\n}"),a("br"),t._v("\nprintSquare(5);")]),t._v(" "),a("p",[t._v("当Javascript引擎在执行这段代码的前一刻，Call Stack是空的。然后Call Stack将会按照下图发生变化。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop3.png",alt:"Javascript异步"}})]),t._v(" "),a("p",[a("strong",[t._v("看下面的代码")]),t._v("，这段代码模拟在Call Stack中出现异常后的全过程。")]),t._v(" "),a("p",[t._v("function foo() {"),a("br"),t._v("\nthrow new Error('SessionStack will help you resolve crashes 😃');"),a("br"),t._v("\n}"),a("br"),t._v("\nfunction bar() {"),a("br"),t._v("\nfoo();"),a("br"),t._v("\n}"),a("br"),t._v("\nfunction start() {"),a("br"),t._v("\nbar();"),a("br"),t._v("\n}"),a("br"),t._v("\nstart();")]),t._v(" "),a("p",[t._v("假设这段代码在foo.js中，foo.js在chrome浏览器执行后将会出现下面的堆栈追踪记录。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop6.png",alt:"Javascript异步"}})]),t._v(" "),a("p",[t._v("**堆栈溢出：**Javascript引擎产生的堆栈超过Javascript运行环境所提供的最大数量。这种异常在代码中存在递归但没有设置递归结束的条件时，尤其容易产生。")]),t._v(" "),a("p",[t._v("下面就是这种类型的代码：")]),t._v(" "),a("p",[t._v("function foo() {"),a("br"),t._v("\nfoo();"),a("br"),t._v("\n}"),a("br"),t._v("\nfoo();")]),t._v(" "),a("p",[t._v("Javascript引擎执行这段代码是从foo函数开始，在这个函数中不断调用自己并没有设置终止条件，从而产生无限循环。每一次执行foo，Call Stack都会添加一次函数。这就像下面显示的那样：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop7.png",alt:"Javascript异步"}})]),t._v(" "),a("p",[t._v("当Javascript引擎中的Call Stack的长度，超过Javascript执行环境中Call Stack的实际长度时，Javascript执行环境（Chrome浏览器或Node）就会抛出下面的异常。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop8.png",alt:"Javascript异步"}})]),t._v(" "),a("p",[t._v("在多线程环境中，要考虑诸如死锁等复杂执行过程。单线程的环境中相比较要简单很多，但是单线程同样有它的限制。Javascript单线程的执行环境中，如何应对复杂的调用，单线程会不会限制程序的性能。")]),t._v(" "),a("h3",{attrs:{id:"并发-concurrence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发-concurrence"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#%E5%B9%B6%E5%8F%91%EF%BC%88concurrence%EF%BC%89",title:"并发（concurrence）",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("并发（concurrence）")]),t._v(" "),a("p",[t._v("当在你的Call Stack中存在一个需要占用相当大执行时间的函数时，将会发生什么。例如在浏览器中通过Javascript传输一个比较大的image文件时，你会怎么做？")]),t._v(" "),a("p",[t._v("你也许会问这怎么也算是一个问题。当Call Stack有待执行的函数时，浏览器会阻塞在这里，并不做其它的任务。这也意味着你不可能在app中呈现流畅复杂的UI。")]),t._v(" "),a("p",[t._v("问题不仅仅如此，一旦Call Stack中等待执行的任务很多时，浏览器要在很长的时间内都不能回应其它事件。许多浏览器这时都会抛出一个提示信息，征求你是否要关闭页面。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop5.jpeg",alt:"Javascript异步"}})]),t._v(" "),a("p",[t._v("这样必然将导致非常差的用户体验。")]),t._v(" "),a("h3",{attrs:{id:"event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#Event-loop",title:"Event loop",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("Event loop")]),t._v(" "),a("p",[t._v("浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。"),a("strong",[t._v("宏任务队列可以有多个，微任务队列只有一个")]),t._v("。")]),t._v(" "),a("ul",[a("li",[t._v("常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等")]),t._v(" "),a("li",[t._v("常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。")])]),t._v(" "),a("h4",{attrs:{id:"过程解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过程解析"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90",title:"过程解析",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("过程解析")]),t._v(" "),a("p",[t._v("一个完整的 Event Loop 过程，可以概括为以下阶段：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop9.png",alt:"Javascript异步"}})]),t._v(" "),a("p",[t._v("导图要表达的内容用文字来表述的话：")]),t._v(" "),a("ul",[a("li",[t._v("同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。")]),t._v(" "),a("li",[t._v("当指定的事情完成时，Event Table会将这个函数移入Event Queue。")]),t._v(" "),a("li",[t._v("主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。")]),t._v(" "),a("li",[t._v("上述过程会不断重复，也就是常说的Event Loop(事件循环)。")])]),t._v(" "),a("p",[t._v("我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。")]),t._v(" "),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://gitlib.com/page/js-eventloop.html#%E6%80%BB%E7%BB%93",title:"总结",target:"_blank",rel:"noopener noreferrer"}},[a("OutboundLink")],1),t._v("总结")]),t._v(" "),a("p",[t._v("事件的执行顺序，"),a("code",[t._v("是先执行宏任务，然后执行微任务")]),t._v("，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中("),a("code",[t._v("宏任务和微任务是不同的Event Queue")]),t._v(")，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.gitlib.com/blog/2019/11/12/js-eventloop10.png",alt:"Javascript异步"}})]),t._v(" "),a("hr")])}),[],!1,null,null,null);a.default=v.exports}}]);