(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{509:function(s,n,e){"use strict";e.r(n);var a=e(9),t=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[n("a",{attrs:{href:"https://leetcode-cn.com/problems/regular-expression-matching/",target:"_blank",rel:"noopener noreferrer"}},[s._v("LC link"),n("OutboundLink")],1),s._v(" "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s/rnaFK05IcFWvNN1ppNf2ug",target:"_blank",rel:"noopener noreferrer"}},[s._v("explanation"),n("OutboundLink")],1)]),s._v(" "),n("p",[n("img",{attrs:{src:"https://raw.githubusercontent.com/emmableu/image/master/10-0.png",alt:""}}),s._v(" "),n("img",{attrs:{src:"https://raw.githubusercontent.com/emmableu/image/master/10-1.png",alt:""}})]),s._v(" "),n("h2",{attrs:{id:"solution"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#solution"}},[s._v("#")]),s._v(" Solution")]),s._v(" "),n("p",[n("strong",[s._v("正则表达算法问题只需要把住一个基本点：看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可。")])]),s._v(" "),n("p",[s._v("如果不考虑"),n("code",[s._v("*")]),s._v("通配符，面对两个待匹配字符"),n("code",[s._v("s[i]")]),s._v("和"),n("code",[s._v("p[j]")]),s._v("，我们唯一能做的就是看他俩是否匹配：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("bool isMatch(string s, string p) {\n    int i = 0, j = 0;\n    while (i < s.size() && j < p.size()) {\n        // 「.」通配符就是万金油\n        if (s[i] == p[j] || p[j] == '.') {\n            // 匹配，接着匹配 s[i+1..] 和 p[j+1..]\n            i++; j++;\n        } else {\n            // 不匹配\n            return false;\n        }\n    }\n    return i == j;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("p",[s._v("用python实现：")]),s._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("那么考虑一下，如果加入"),n("code",[s._v("*")]),s._v("通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。")]),s._v(" "),n("p",[s._v("当"),n("code",[s._v("p[j + 1]")]),s._v("为"),n("code",[s._v("*")]),s._v("通配符时，我们分情况讨论下：")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("如果匹配，即"),n("code",[s._v("s[i] == p[j]")]),s._v("，那么有两种情况：")]),s._v(" "),n("ul",[n("li",[n("p",[n("code",[s._v("p[j]")]),s._v("有可能会匹配多个字符，比如"),n("code",[s._v('s = "aaa"')]),s._v(", "),n("code",[s._v('p = "a*"')]),s._v("，那么"),n("code",[s._v("p[0]")]),s._v("会通过"),n("code",[s._v("*")]),s._v("匹配 3 个字符"),n("code",[s._v('"a"')]),s._v("。")])]),s._v(" "),n("li",[n("p",[n("code",[s._v("p[i]")]),s._v("也有可能匹配 0 个字符，比如"),n("code",[s._v('s = "aa"')]),s._v(", "),n("code",[s._v('p = "a*aa"')]),s._v("，由于后面的字符可以匹配"),n("code",[s._v("s")]),s._v("，所以"),n("code",[s._v("p[0]")]),s._v("只能匹配 0 次。")])])])])]),s._v(" "),n("p",[s._v("2、如果不匹配，即"),n("code",[s._v("s[i] != p[j]")]),s._v("，只有一种情况：")]),s._v(" "),n("p",[n("code",[s._v("p[j]")]),s._v("只能匹配 0 次，然后看下一个字符是否能和"),n("code",[s._v("s[i]")]),s._v("匹配。比如说"),n("code",[s._v('s = "aa"')]),s._v(","),n("code",[s._v('p = "b*aa"')]),s._v("，此时p[0]只能匹配 0 次。")]),s._v(" "),n("p",[s._v("综上，可以把之前的代码针对"),n("code",[s._v("*")]),s._v("通配符进行一下改造：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("if (s[i] == p[j] || p[j] == '.') {\n    // 匹配\n    if (j < p.size() - 1 && p[j + 1] == '*') {\n        // 有 * 通配符，可以匹配 0 次或多次\n    } else {\n        // 无 * 通配符，老老实实匹配 1 次\n        i++; j++;\n    }\n} else {\n    // 不匹配\n    if (j < p.size() - 1 && p[j + 1] == '*') {\n        // 有 * 通配符，只能匹配 0 次\n    } else {\n        // 无 * 通配符，匹配无法进行下去了\n        return false;\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("p",[s._v("整体的思路已经很清晰了，但现在的问题是，遇到*通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？")]),s._v(" "),n("p",[s._v("你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」，「状态」无非就是i和j两个指针的位置，「选择」就是p[j]选择匹配几个字符。")]),s._v(" "),n("h3",{attrs:{id:"dp-解法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dp-解法"}},[s._v("#")]),s._v(" DP 解法")])])}),[],!1,null,null,null);n.default=t.exports}}]);